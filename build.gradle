task cleantmp {
    doFirst {
        def commonfolder = file('./build/tmp/common')
        if(commonfolder.exists()) {
            delete commonfolder
        }
        gradle.ext.mcversions.each {
            def folder = file('./build/tmp/' + it)
            if(folder.exists()) {
                delete folder
            }
            def fabrictmp = file('./build/tmp/fabric' + it)
            if(fabrictmp.exists()) {
                delete fabrictmp
            }
            def forgetmp = file('./build/tmp/forge' + it)
            if(forgetmp.exists()) {
                delete forgetmp
            }
        }
    }
}

task unpackjars {
    dependsOn ':cleantmp'
    dependsOn ':common:build'
    gradle.ext.mcversions.each {
		dependsOn ':fabric' + it + ':build'
		dependsOn ':forge' + it + ':build'
	}
    
    def commonfolder = file('./build/tmp/common')
    
    doFirst {
        copy {
            from fileTree('./common/resources')
            into commonfolder
        }
        copy {
            from zipTree('./common/build/libs/common.jar')
            into commonfolder
        }
        
        gradle.ext.mcversions.each {
            def mcversion = it
            def folder = file('./build/tmp/' + mcversion)
            file(folder.absolutePath + '/META-INF').mkdirs()
            
            def manifest = file('./build/tmp/' + mcversion + '/META-INF/MANIFEST.MF')
            manifest.text = 'Manifest-Version: 1.0\n'
            
            def fabrictmp = file('./build/tmp/fabric' + mcversion)
            copy {
                from zipTree('./fabric' + mcversion + '/build/libs/' + gradle.ext.fabricname + '-' + gradle.ext.modversion + '.jar')
                into fabrictmp
            }
            fileTree(fabrictmp).each {
                def relpath = it.absolutePath.substring(fabrictmp.absolutePath.length())
                def target = file(folder.absolutePath + relpath)
                if(relpath == '\\META-INF\\MANIFEST.MF') {
                    manifest.text += it.text.substring(it.text.indexOf('\n') + 1)
                }else if(!target.exists()){
                    def source = it
                    def targetParent = target.getParentFile()
                    targetParent.mkdirs()
                    copy {
                        from source
                        into targetParent
                    }
                }
            }
            
            def forgetmp = file('./build/tmp/forge' + mcversion)
            copy {
                from zipTree('./forge' + mcversion + '/build/libs/' + gradle.ext.forgename + '-' + gradle.ext.modversion + '.jar')
                into forgetmp
            }
            fileTree(forgetmp).each {
                def relpath = it.absolutePath.substring(forgetmp.absolutePath.length())
                def target = file(folder.absolutePath + relpath)
                if(relpath == '\\META-INF\\MANIFEST.MF') {
                    manifest.text += it.text.substring(it.text.indexOf('\n') + 1)
                }else if(!target.exists()){
                    def source = it
                    def targetParent = target.getParentFile()
                    targetParent.mkdirs()
                    copy {
                        from source
                        into targetParent
                    }
                }
            }
        }
    }
    
	doLast {
		delete commonfolder.absolutePath + '/META-INF'
		
		gradle.ext.mcversions.each {
            def folder = file('./build/tmp/' + it)
			fileTree(commonfolder).each {
				def relpath = it.absolutePath.substring(commonfolder.absolutePath.length())
				def target = file(folder.absolutePath + relpath)
				if(relpath != '\\META-INF\\MANIFEST.MF' && !target.exists()) {
					def source = it
					def targetParent = target.getParentFile()
					targetParent.mkdirs()
					copy {
						from source
						into targetParent
					}
				}
			}
		}
	}
}

gradle.ext.mcversions.each {
	def mcversion = it
	task "zip$it"(type: Zip, dependsOn: "unpackjars") {
        dependsOn ':unpackjars'
		from fileTree('./build/tmp/' + mcversion)
		archiveName = rootProject.name + "-" + mcversion + "-" + gradle.ext.modversion + ".jar"
		destinationDir = file('./build/libs')
	}
}

task build {
	gradle.ext.mcversions.each {
		dependsOn tasks.getByName("zip$it")
	}
}

configure(subprojects.findAll {it.name != 'common'}) {
	apply plugin: 'java'
    apply plugin: 'eclipse'
	dependencies {
		implementation project(":common")
	}
    sourceSets.main {
        java {
            srcDir '../common/src'
        }
        resources {
            srcDir '../common/resources'
        }
    }
    eclipse {
        classpath {
            file {
                whenMerged { classpath ->
                    classpath.entries.findAll{ it.kind == 'src' && it.hasProperty("dir") && (it.dir.toString().endsWith("\\common\\src") || it.dir.toString().endsWith("\\common\\resources")) }.each {
                        classpath.entries.remove(it)
                    }
                }
            }
        }
        project.file.withXml {
            def res = it.asNode().get('linkedResources')[0]
            res.link.findAll{ it.location[0].text().endsWith('/common/src') || it.location[0].text().endsWith('/common/resources') }.each {
                res.remove(it)
            }
        }
    }
}