task unpackjars {
	def commonfolder = file('./build/tmp/common')
	if(commonfolder.exists()) {
		delete commonfolder
	}
    copy {
        from fileTree('./common/resources')
        into commonfolder
    }
    
    gradle.ext.mcversions.each {
        def folder = file('./build/tmp/' + it)
        if(folder.exists()) {
            delete folder
        }
        file(folder.absolutePath + '/META-INF').mkdirs()
        
        def manifest = file('./build/tmp/' + it + '/META-INF/MANIFEST.MF')
        manifest.text = 'Manifest-Version: 1.0\n'
        
        def fabricjar = file('./fabric' + it + '/build/libs/' + gradle.ext.fabricname + '-' + gradle.ext.modversion + '.jar')
        if(fabricjar.exists()) {
            def fabrictmp = file('./build/tmp/fabric' + it)
            if(fabrictmp.exists()) {
                delete fabrictmp
            }
            copy {
                from(zipTree(fabricjar))
                into(fabrictmp)
            }
            fileTree(fabrictmp).each {
                def relpath = it.absolutePath.substring(fabrictmp.absolutePath.length())
                def target = file(folder.absolutePath + relpath)
                if(relpath == '\\META-INF\\MANIFEST.MF') {
                    manifest.text += it.text.substring(it.text.indexOf('\n') + 1)
                }else if(!target.exists()){
                    def source = it
                    def targetParent = target.getParentFile()
                    targetParent.mkdirs()
                    copy {
                        from source
                        into targetParent
                    }
                }
            }
        }
        
        def forgejar = file('./forge' + it + '/build/libs/' + gradle.ext.forgename + '-' + gradle.ext.modversion + '.jar')
        if(forgejar.exists()) {
            def forgetmp = file('./build/tmp/forge' + it)
            if(forgetmp.exists()) {
                delete forgetmp
            }
            copy {
                from(zipTree(forgejar))
                into(forgetmp)
            }
            fileTree(forgetmp).each {
                def relpath = it.absolutePath.substring(forgetmp.absolutePath.length())
                def target = file(folder.absolutePath + relpath)
                if(relpath == '\\META-INF\\MANIFEST.MF') {
                    manifest.text += it.text.substring(it.text.indexOf('\n') + 1)
                }else if(!target.exists()){
                    def source = it
                    def targetParent = target.getParentFile()
                    targetParent.mkdirs()
                    copy {
                        from source
                        into targetParent
                    }
                }
            }
        }
    }
    
	doLast {
		copy {
			from zipTree('./common/build/libs/common.jar')
			into commonfolder
		}
		delete commonfolder.absolutePath + '/META-INF'
		
		gradle.ext.mcversions.each {
            def folder = file('./build/tmp/' + it)
			fileTree(commonfolder).each {
				def relpath = it.absolutePath.substring(commonfolder.absolutePath.length())
				def target = file(folder.absolutePath + relpath)
				if(relpath != '\\META-INF\\MANIFEST.MF' && !target.exists()) {
					def source = it
					def targetParent = target.getParentFile()
					targetParent.mkdirs()
					copy {
						from source
						into targetParent
					}
				}
			}
		}
	}
}

gradle.ext.mcversions.each {
	def mcversion = it
	task "zip$it"(type: Zip, dependsOn: "unpackjars") {
		dependsOn ':fabric' + mcversion + ':build'
		dependsOn ':forge' + mcversion + ':build'
		from fileTree('./build/tmp/' + mcversion)
		archiveName = rootProject.name + "-" + mcversion + "-" + gradle.ext.modversion + ".jar"
		destinationDir = file('./build/libs')
	}
}

task build {
	dependsOn unpackjars
	gradle.ext.mcversions.each {
		dependsOn tasks.getByName("zip$it")
	}
}

configure(subprojects.findAll {it.name != 'common'}) {
	apply plugin: 'java'
    apply plugin: 'eclipse'
	dependencies {
		implementation project(":common")
	}
    sourceSets.main {
        java {
            srcDir '../common/src'
        }
        resources {
            srcDir '../common/resources'
        }
    }
    eclipse {
        classpath {
            file {
                whenMerged { classpath ->
                    classpath.entries.findAll{ it.kind == 'src' && it.hasProperty("dir") && (it.dir.toString().endsWith("\\common\\src") || it.dir.toString().endsWith("\\common\\resources")) }.each {
                        classpath.entries.remove(it)
                    }
                }
            }
        }
        project.file.withXml {
            def res = it.asNode().get('linkedResources')[0]
            res.link.findAll{ it.location[0].text().endsWith('/common/src') || it.location[0].text().endsWith('/common/resources') }.each {
                res.remove(it)
            }
        }
    }
}